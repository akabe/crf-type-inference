open Slap.D

(** [vertex_log_potential ff w expr] returns a log potential of subexpression
    [e]. [ff] is a feature function for subexpressions, and [w] is a weight
    vector. *)
val vertex_log_potential :
  (('a, 'b) Lambda.t -> ('n, 'x_cd) vec) ->
  ('n, 'w_cd) vec ->
  ('a, 'b) Lambda.t -> float

(** [graph_log_potential ff w expr] returns a log potential of expression [e].
    [ff] is a feature function for subexpressions, and [w] is a weight vector.*)
val graph_log_potential :
  (('a, 'b) Lambda.t -> ('n, 'x_cd) vec) ->
  ('n, 'w_cd) vec ->
  ('a, 'b) Lambda.t -> float

(** [vertex_potential ff w expr] returns a potential of subexpression [e].
    [ff] is a feature function for subexpressions, and [w] is a weight vector.*)
val vertex_potential :
  (('a, 'b) Lambda.t -> ('n, 'x_cd) vec) ->
  ('n, 'w_cd) vec ->
  ('a, 'b) Lambda.t -> float

(** [graph_potential ff w expr] returns a potential of expression [e].
    [ff] is a feature function for subexpressions, and [w] is a weight vector.*)
val graph_potential :
  (('a, 'b) Lambda.t -> ('n, 'x_cd) vec) ->
  ('n, 'w_cd) vec ->
  ('a, 'b) Lambda.t -> float

(** [graph_feature ff expr] returns a feature of expression [e] where
    [ff] is a feature function for subexpressions. *)
val graph_feature :
  (('a, 'b) Lambda.t -> ('n, 'cd) vec) ->
  ('a, 'b) Lambda.t -> ('n, 'cd) vec

val normalizer :
  types:'b list ->
  (('a, 'b) Lambda.t -> ('n, 'cd) vec) ->
  ('n, 'w_cd) vec ->
  ('a, _) Lambda.t -> float

val log_likelihood :
  types:'b list ->
  (('a, 'b) Lambda.t -> ('n, 'x_cd) vec) ->
  ('a, 'b) Lambda.t list ->
  ('n, 'w_cd) vec -> float

val log_posterior :
  types:'b list ->
  sigma2:float ->
  (('a, 'b) Lambda.t -> ('n, 'x_cd) vec) ->
  ('a, 'b) Lambda.t list ->
  ('n, 'w_cd) vec -> float

val grad_log_likelihood :
  types:'b list ->
  (('a, 'b) Lambda.t -> ('n, 'x_cd) vec) ->
  ('a, 'b) Lambda.t list ->
  ('n, 'w_cd) vec -> ('n, 'cnt) vec

val grad_log_posterior :
  types:'b list ->
  sigma2:float ->
  (('a, 'b) Lambda.t -> ('n, 'x_cd) vec) ->
  ('a, 'b) Lambda.t list ->
  ('n, 'w_cd) vec -> ('n, 'cnt) vec

(** {2 Inference} *)

(** [infer ~types vlp expr] infers type annotations of expression [expr].
    [types] is a list of candidates of type annotations, and [vlp] is a log
    potential function for subexpressions.
    @return [(expr', lp)] where [expr'] is type-annotated expression and [lp] is
    the log potential of [e']. This function implements Viterbi-based exact
    algorithm of exponential time in worse case. *)
val infer :
  types:'b list ->
  (('a, 'b) Lambda.t -> float) ->
  ('a, _) Lambda.t -> ('a, 'b) Lambda.t * float

(** {2 Parameter estimation (Gibbs sampling)} *)

module GibbsSampling : sig
  type t =
    {
      gs_seqs : int; (** # of sequences to be generated by Gibbs sampler. *)
      gs_samples : int; (** # of samples. *)
      gs_period : int; (** Sampling period. *)
      gs_burn_in : int; (** # of steps for convergence. *)
    }

  val fold :
    rng:Gsl.Rng.t ->
    sampler:t ->
    types:'b list ->
    (('a, 'b) Lambda.t -> float) ->
    ('accum -> ('a, 'b) Lambda.t -> 'accum) -> 'accum ->
    ('a, 'c) Lambda.t -> 'accum

  (** [grad_log_likelihood ~rng ~sampler ~types ff exprs w] computes log
      likelihood approximated by Gibbs sampling. [ff] is a feature function for
      subexpressions, [types] is a list of candidates of type annotations, [w]
      is a weight vector, and [exprs] is a list of expressions.
      @return the gradient of log likelihood. *)
  val grad_log_likelihood :
    rng:Gsl.Rng.t ->
    sampler:t ->
    types:'b list ->
    (('a, 'b) Lambda.t -> ('n, 'x_cd) vec) ->
    ('a, 'b) Lambda.t list ->
    ('n, 'w_cd) vec -> ('n, 'cnt) vec

  (** [grad_log_posterior ~rng ~sampler ~types ~sigma2 ff exprs w] computes log
      posterior approximated by Gibbs sampling. [sigma2] is a variance of
      Gaussian prior, [ff] is a feature function for subexpressions, [types] is
      a list of candidates of type annotations, [w] is a weight vector, and
      [exprs] is a list of expressions.
      @return the gradient of log posterior (Gaussian prior). *)
  val grad_log_posterior :
    rng:Gsl.Rng.t ->
    sampler:t ->
    types:'b list ->
    sigma2:float ->
    (('a, 'b) Lambda.t -> ('n, 'x_cd) vec) ->
    ('a, 'b) Lambda.t list ->
    ('n, 'w_cd) vec -> ('n, 'cnt) vec

  (** [normalizer ~rng ~sampler ~types ff w expr] returns the inverse of the
      normalization coefficient for expression [expr]. [ff] is a feature
      function for subexpressions, [types] is a list of candidates of type
      annotations, and [w] is a weight vector. *)
  val normalizer :
    rng:Gsl.Rng.t ->
    sampler:t ->
    types:'b list ->
    (('a, 'b) Lambda.t -> ('n, 'x_cd) vec) ->
    ('n, 'w_cd) vec ->
    ('a, 'b) Lambda.t -> float

  (** [prob ~rng ~sampler ~types ff w expr] returns the conditional probability
      of expression [expr]. [ff] is a feature function for subexpressions,
      [types] is a list of candidates of type annotations, and [w] is a weight
      vector. *)
  val prob :
    rng:Gsl.Rng.t ->
    sampler:t ->
    types:'b list ->
    (('a, 'b) Lambda.t -> ('n, 'x_cd) vec) ->
    ('n, 'w_cd) vec ->
    ('a, 'b) Lambda.t -> float

  val likelihood :
    rng:Gsl.Rng.t ->
    sampler:t ->
    types:'b list ->
    (('a, 'b) Lambda.t -> ('n, 'x_cd) vec) ->
    ('a, 'b) Lambda.t list ->
    ('n, 'w_cd) vec -> float

  val grad_log_likelihood_switch :
    ?c1:float -> ?c2:float ->
    rng:Gsl.Rng.t ->
    sampler:t ->
    types:SimpleType.t list ->
    (('a, SimpleType.t) Lambda.t -> ('n, 'x_cd) vec) ->
    ('a, SimpleType.t) Lambda.t list ->
    ('n, 'w_cd) vec -> ('n, 'cnt) vec
end

(** {2 Parameter estimation (brute force)} *)

module BruteForce : sig
  val fold :
    types:'b list ->
    ('accum -> ('a, 'b) Lambda.t -> 'accum) ->
    'accum ->
    ('a, _) Lambda.t -> 'accum

  val grad_log_likelihood :
    types:'b list ->
    (('a, 'b) Lambda.t -> ('n, 'x_cd) vec) ->
    ('a, 'b) Lambda.t list ->
    ('n, 'w_cd) vec -> ('n, 'cnt) vec

  val grad_log_posterior :
    types:'b list ->
    sigma2:float ->
    (('a, 'b) Lambda.t -> ('n, 'x_cd) vec) ->
    ('a, 'b) Lambda.t list ->
    ('n, 'w_cd) vec -> ('n, 'cnt) vec

  val normalizer :
    types:'b list ->
    (('a, 'b) Lambda.t -> ('n, 'x_cd) vec) ->
    ('n, 'w_cd) vec ->
    ('a, _) Lambda.t -> float

  val prob :
    types:'b list ->
    (('a, 'b) Lambda.t -> ('n, 'x_cd) vec) ->
    ('n, 'w_cd) vec ->
    ('a, 'b) Lambda.t -> float

  val infer :
    types:'b list ->
    (('a, 'b) Lambda.t -> ('n, 'x_cd) vec) ->
    ('n, 'w_cd) vec ->
    ('a, _) Lambda.t -> ('a, 'b) Lambda.t * float
end

(** {2 Evaluation} *)

type 'a confusion_matrix

val confusion_matrix :
  types:'b list ->
  unifiable:('c list ref -> 'b -> 'b -> bool) ->
  (('a, 'b) Lambda.t * ('a, 'b) Lambda.t) list -> 'b confusion_matrix

val pp_confusion_matrix :
  (Format.formatter -> 'a -> unit) ->
  Format.formatter -> 'a confusion_matrix -> unit

val accuracy : 'a confusion_matrix -> float

type score =
  {
    precision : float;
    recall : float;
    f1 : float;
  }

val score_matrix : 'a confusion_matrix -> ('a * score) option list

val pp_score_matrix :
  (Format.formatter -> 'a -> unit) ->
  Format.formatter -> ('a * score) option list -> unit
